% ----------------------------------------------------------------
      \section{Intermezzio: grid, coordinates, and lattices} \label{sec:hpp}
% ----------------------------------------------------------------

\Fig{lattices}{
   \begin{tabular}{ccccc}       
          \includegraphics[scale=.8]{xfig/RectLat.eps}                     &
          \includegraphics[scale=.8]{xfig/RectLat23.eps}                   &
          \includegraphics[scale=.8]{xfig/Skew1Lat23.eps}                  &
          \includegraphics[scale=.8]{xfig/Skew1Lat23Generators.eps}        &
             \includegraphics[scale=.8]{xfig/Skew1Lat23SizeSkew.eps}       \\
%          \begin{tabular}{c}
%              \includegraphics[scale=.8]{xfig/Skew1Lat23Generators.eps}   \\ 
%              generators     
%	  \end{tabular}                                                    &
%          \begin{tabular}{c}
%              \includegraphics[scale=.8]{xfig/Skew1Lat23SizeSkew.eps}     \\
%              size and skew
%          \end{tabular}                                                    \\
      $\left( \begin{array}{cc}
               1 & 0 \\
               0 & 1 
                \end{array} \right) $ & 
      $\left( \begin{array}{cc}
               2 & 0 \\
               0 & 3 
                \end{array} \right) $ & 
      $\left( \begin{array}{cc}
               2 & 1 \\
               0 & 3 
                \end{array} \right) $ &
      generators &
      size and skew                               \\ 
  \end{tabular}
}{{\bf Lattice example} The figure shows three different lattices---an
  \emph{orthonormal lattice} with the same size as the grid, a
  \emph{rectangular lattice} that skips three in the $X$ direction and
  hits every-other row on the $Y$ direction, and a skewed lattice that
  skews by one on successive rows.  The size and generator vectors of the
  skewed lattice are depicted to the right of it.}

Lattices are regularly spaced points and, in SIMP, they must be on the
grid\fnmark.  A set of generator vectors denote the spacing in each
dimension from one lattice site to the next.  An $n$-dimensional
lattice requires $n$ generator vectors.  As shown by the first diagram
in \fig{lattices}, a lattice can be the same size of the grid. In two
dimensions the generators of such a lattice are the unit
vectors---$(1,0)$ for the $Y$ direction and $(0,1)$ for the $X$
direction.  A generator may also `skip' through the grid at a coarser
granularity. In the second diagram of \fig{lattices}, the generators
$(2,0)$ and $(0,3)$ hit every third point in the $X$ direction at
every-other row in the $Y$ direction.  The generators can also be
skewed.  In the third diagram of \fig{lattices}, $(2,1)$ and $(0,3)$
hit every third point in the $X$ direction at every-other row in the
$Y$ direction, but successively skewed by 1 in $X$ at subsequent rows.

\fntext{In general, lattices need not be subsets of an integer grid,
however, using integer lattices allows SIMP and STEP to employ integer
domain computations that are more efficient and numerically accurate
than using the reals (floating point numbers). SIMP does support
rational coordinates by means of the scaling mechanism described in
\secref{sec:pitch}.}

% -------- Begin subscript underscore
\catcode`\_=8   % 

Below each lattice in \fig{lattices} the corresponding generator
vectors are stacked into a generator matrix---the canonical
representation of a lattice in SIMP.  Notice that the generator
matrices are upper-triangular, arranged into a stack of row vectors
ordered from the most significant dimension to the least.
Technically, an $n$ dimensional lattice $\Lambda$ is defined as the
set of points generated by multiplying the generator vectors $~g_i$ by
integers $a_i$,
\[ \Lambda = \{\sum_{i}^{n} a_{i} ~g_{i} : a_i \in \mathbb{Z}\}, \]
or in the matrix formulation by multiplying the generator matrix $~G$ by
an integer vector $~a$,
\[ \Lambda = \{~a~G : ~a \in \mathbb{Z}^n\}. \]

% -------- go back character underscore
\catcode`\_\active\def_{\hackscore{}}

The diagonal elements of the generator matrix declare the lattice's
rectangular size---an orthogonal projection of the lattice onto the
coordinate axes---while the off-diagonal elements give its skew---the
amount in lower coordinate dimensions that the lattice is successively
skewed in higher dimensions.  The rectangular matrix
generator elements on the diagonals of the rectangular lattice $\left(
\begin{array}{cc} 2 & 0 \\ 0 & 3
 \end{array} \right) $ and the skewed lattice $\left( \begin{array}{cc}
 2 & 1 \\ 0 & 3 \end{array} \right) $ are the same $(2,3)$, but the
latter has a skew of 1 in $X$ on its $Y$ generator.  The skew element
of the skewed lattice gives the amount by which the skewed lattice
skews with respect to the rectangular one. The generator, size, and
skew vectors of the skewed lattice are depicted to its right in
\fig{lattices}.

The rectangular size of a lattice is often useful. For example, as a
result of having the same rectangular size, both lattices have the
same number of sites on the grid as demonstrated by \figref{boundary}.
In \secref{select} the size of a lattice is used construct a
rectangular unit cell---a fundamental region for selecting lattice
sites.  As a convenience, when one would like to specify a rectangular
lattice, one may just give its size vector rather than its full
generator matrix.
%and SIMP will use that to make the full generator matrix.
% vector containing the rectangular generator elements 

\Fig{boundary}{
   \begin{tabular}{ccc}       
%        \includegraphics[scale=.8]{xfig/torus.eps}                      &
        \includegraphics[scale=.8]{xfig/RectLatBoundary.eps}            &
        \includegraphics[scale=.8]{xfig/RectLat23Boundary.eps}          &
        \includegraphics[scale=.8]{xfig/Skew1Lat23Boundary.eps}           % \\
%    torus & \multicolumn{3}{c}{points at the edges wrap around} 
    \end{tabular}
}{{\bf Boundaries and wrap-around} 
    The coordinate space wraps around on a torus.  In the lattice
    diagrams above, points on the edge are hollow and, because of the
    toroidal wrap-around, are the same as the solid points opposite to
    them. The solid lines indicate that the boundary is closed in the 
    direction of smaller coordinates and the dotted lines indicate that they
    are open in the direction of larger coordinates. }

% -------- Begin subscript underscore
\catcode`\_=8   % 

Although any full rank, linearly independent $n\times n$ generator
matrix generates a lattice, in SIMP, the generator matrices of
lattices must 
\begin{itemize}
  \item be upper-triangular, 
  \item have strictly positive integers in their size vectors (diagonals), 
  \item and have non-negative, integers skew elements that are smaller than 
        the lattice size in dimension they skew.
\end{itemize}
Together, these constraints are called integer Hermite normal form
(HNF). Formally, a generator matrix $~G$ is in HNF \emph{iff}
% http://matwhorld.wolfram.com/HermiteNormalForm.html
\begin{itemize}
  \item $g_{ij}=0 $ for $j>i$ ($~G$ is upper-triangular),
  \item $0<g_{ii}$ for all i, and
  \item $0\leq g_{ij} <g_{ii}$ for $j<i$.
\end{itemize}
It is also a theorem of linear algebra that, given a square $n\times n$
nonsingular integer matrix $~A$, there exists an $n\times n$ unimodular matrix 
$~U$ and an $n\times n$ matrix $~H$ (known as the Hermite normal form of $~A$) 
such that
\[    ~A~U=~H \]
This means that one can convert any integer lattice generator matrix
to one that is in HNF by using transformations that merely rotate the
lattice and change its generator vectors to shorter ones that satisfy
the HNF constraints.  (The resulting HNF matrix may have rational
elements.  To get an \emph{integer} HNF matrix of an integer lattice,
generally one will also need to apply a integer scaling to the matrix
in order to factor out the least common denominator of any rationals
that appear the HNF result.)  Therefore, the HNF is suitable for
representing \emph{any} integer matrix.


Consider the non-HNF generator matrix  
$ \left( \begin{array}{cc}
             2 & 4 \\
             0 & -3 
              \end{array} \right) $
it may be converted to a HNF as
$ \left( \begin{array}{cc}
             2 & 1 \\
             0 & 3 
              \end{array} \right) $ 
by negating the $X$ generator vector and subtracting the resulting $X$
generator from the $Y$ generator to obtain an $X$ skew that's less
than $3$.  Although SIMP could use an algorithm to convert general
matrices to the integer HNF, we believe that the integer-HNF is quite
natural and users will have no trouble expressing lattice generators
directly in it.  (Furthermore, using an automated conversion technique
would be confusing to the user since SIMP declarations depend on a
specific generator matrix---not a HNF equivalent one.)

Sometimes one would like to use a lattice that can not be expressed as an 
integer lattice. An example is a hexagonal lattice with the generator matrix
    $ \left( \begin{array}{cc}
             \frac{\sqrt{3}}{2} & \frac{1}{2} \\
             0 & 1 
             \end{array} \right) $.  
No uniform scaling of the matrix can convert it to an integer matrix. In such cases, one must find an an approximate generator matrix for an integer
lattice.  Although the exact geometry is lost, the matrix
    $ \left( \begin{array}{cc}
             1 & 1 \\
             0 & 2 
             \end{array} \right) $  
is a reasonable approximation because it maintains same group
relationship among the generators---if we call the $X$ direction
generator $~x$ and the $Y$ direction generator $~y$, one can determine
that the relation $~x-~y=~y$ holds both the original hexagonal lattice and its
integer approximation.

% as a user would need employ it to find the HNF
% matrix of some non-HNF generator matrix, but in this scenario would
% not know the HNF matrix \emph{a priori} and therefore would not know
% the geometry of the declared lattice, which is vital for writing
% rules.




%Lattices are represented by a set of generator vectors arranged as a
%matrix called a generator matrix.  If there are $n$-dimensions, the
%generator matrix is $n\times n$ and composed of $n$
%linearly-independent $n$-dimensional generator row-vectors giving the
%spacing of the lattice in each of the $n$ dimensions.  There are many
%equivalent specifications of a generator-matrix for a lattice, however
%SIMP expects them in a special form called Hermite Normal Form (HNF)
%in which the generator matrix is upper-triangular with strictly positive
%integer diagonal elements and where upper-off diagonal column elements 
%are greater than or equal to zero and less than the diagonal of their 
%column\footnote{Actually, this definition of HNF varies slightly from some 
%other definitions where the matrix may be lower-triangular and off-diagonal
%elements are less than or equal to zero and greater than the absolute value
%of the row components.}.  Because it is a normal form, any lattice with
%integer generators may be expressed this way.  
%
%An example of a HNF matrix is 
%\[ G = \left( \begin{array}{cc}
%             2 & 1 \\
%             0 & 3 
%              \end{array} \right)  \]
%There are two generator vectors, $(0,3)$ in the least significant dimension
%and $(2,1)$ in the most significant dimension. 
%
%To arrive at HNF expression of a lattice from an arbitrary lattice $n$
%dimensional lattice, think of successively rotating the lattice so
%that it first aligns with the X axis, then with the YX plane and then
%the ZYX hyper-plane and so on for each of the $n$ dimensions.  One
%arrives at a set of generator vectors for each of the successive
%coordinate hyper-plane subspaces.  The Y component of the new
%generator vector associated with the YX subspace defines the extension
%of the lattice in to the Y dimension---each successive generator
%defines the extension of the lattice into a new corrdinate
%dimension. (To make the generator vectors positive, one should also
%'reflect' the lattice while rotating it.)  Similar to the coordinate
%indexing conventions, we arrange the generators in to a matrix by
%stacking generator vectors going down from the generator that extends
%into the 'most significant' subspace to to the least.  One more step
%remains in the normalization process---one would like the shortest 
%expression of these generator vectors so that the skew of generators 
%(as expressed by components of lesser dimension) is smaller than the 
%generator for that dimension  [need to clean up the language here]. This
%can be achieved by 'subtracting out' lower dimensional generators until 
%the remainder is positive and components are greater than zero and less
%than 1. 

%\subsection{lattice declaration}

%  [show figures for each].
% say 'snap-to'


% --------------------------------
\subsection{Selecting lattice sites with coordinates and slices} \label{select}
% --------------------------------
When reading and writing data and specifying neighbors, one uses
coordinates to select sites.  In this section, we discuss
how coordinates select lattice sites and how slices select multiple
sites.  We start with a method for selecting sites.

As discussed in \fig{selection0}, a coordinate may or may not hit a
lattice site. Therefore, to ensure that a coordinate always selects a
lattice site, SIMP interprets a coordinate $~w$ as selecting
\emph{the} lattice site inside of the rectangular unit cell at
$~w$---that is, the site at coordinate $~v$, where $~w \leq ~v <
~w+~h$ and $~h$ is the rectangular size vector of the lattice.
Because the region $\{~v : 0 \leq ~v < ~h\}$ is a unit cell of a
lattice given by a HNF matrix $G$ having $~h$ as its diagonal, it is
guaranteed to contain one and only one lattice point.
\fig{selection1} (a) demonstrates that the rectangular unit cell works
with skewed lattices while (b) demonstrates that it is scaled to the
pitch of the lattice. Notice that the rectangles are closed at lower
index values and open at higher values.  Sites on an open boundary are
not selected.

\Fig{selection0}{
   \begin{tabular}{cccc}       
        \includegraphics[scale=.8]{xfig/RectLat23Select23x.eps}           &
        \includegraphics[scale=.8]{xfig/RectLat23Select12x.eps}           &
        \includegraphics[scale=.8]{xfig/RectLat23Select12X.eps}           &
        \includegraphics[scale=.8]{xfig/RectLat23Select23X.eps}           \\
    (a) & (b) & (c) & (d)    
    \end{tabular}
}{ {\bf Selecting sites with coordinates}
   The coordinate $(2,3)$ marked with an X in (a) hits a lattice site
   (the black one), but $(2,2)$ in (b) does not.  To ensure that a
   coordinate selects a lattice site, we interpret a coordinate $~w$
   as selecting the site at index $~v$ in the range $~w\leq ~v <
   ~w+~h$---the rectangular unit cell region of the lattice where $~h$ is
   the size vector (diagonal) of the lattice's generators.  In (c) the
   rectangular unit cell region of $(1,1)$ is shaded and the site
   selected by it is black.  (d) demonstrates that using rectangular
   unit cell regions is a special case of directly selecting a site
   with its coordinate.}


Rectangular slices are given rectangular regions ranging from a
coordinate $~w$ to a coordinate $~v$. The coordinate pair forms
bounding rectangle for selecting multiple sites.  In order to select a
fixed size rectangular array of sites, the size of the slice must be a
multiple of the lattice size in each dimension.  Basically,
rectangular slices are multiples of the rectangular unit cell and
select all sites at in the coordinate region $\{ ~v: ~w \leq ~v <
w+v\}$.  For a lattice with size $~h$, $~w$ and $~v$ must
satisfy
\[ k_i h_i = v_i - w_i \ \mathrm{where}\  k_i \in \mathbb{Z}.\]
in order for the region to be a multiple of the rectangular unit cell.


When using slices to read data variables, an array holding the data
values at the lattice sites is returned.  This array is guaranteed to
be rectangular because of the above constraints, however, a way to
associate lattice points with coordinates is still needed.  Using the
rectangular unit cell to generate the array indices is a natural way
to do it.  The rectangular size of the lattice gives the size of the
array as $~k=(~v-~w)/~h$ (with division computed element-wise). The
array index $~a$ is an integer vector in the range $0\leq ~a < ~k$.
We collapse the lattice coordinates into array indices by associating
each lattice point with the index of the rectangular unit cell that
it's in as shown in \fig{selection1} (c,d).  Specifically, for a site
with the coordinate $v$ the array index is computed with
\[  ~a = \lfloor (~v-~w)/~h \rfloor. \]


\Fig{selection1}{
   \begin{tabular}{cccc}       
%        \includegraphics[scale=.8]{xfig/RectLat23Select31.eps}           &
        \includegraphics[scale=.8]{xfig/Skew1Lat23Select31.eps}        &
        \includegraphics[scale=.8]{xfig/RectLat22Select31.eps}         &  
        \includegraphics[scale=.8]{xfig/RectLat22Select01to45.eps}     &
        \includegraphics[scale=.8]{xfig/Skew1Lat23Select15to58.eps}    \\
    (a) & (b) & (c) & (d)  
    \end{tabular}
}{ {\bf Selecting sites with coordinates and slices} The rectangular
    unit cell works with skewed lattices as shown in (a) and is scaled
    to the size of the lattice as shown in (b). In both, the
    coordinate selected is $(3,1)$.  Rectangular slices given by a pair
    of coordinates.  In (c), the slice is from $(0,1)$ to $(4,5)$ and
    selects four sites. They are marked and labeled with their array
    indexes, which come from the rectangular unit cell that they are
    in.  In (d), the slice is from $(1,5)$ to $(5,8)$ and two sites
    are selected.  Notice that this slice wraps around.}



% --------------------------------
\subsection{Shifting lattice to alternate starting positions} 
\label{sec:position}
% --------------------------------

%The fourth lattice is the same as the one before it except that it has 
%been is shifted and starts at $(1,1)$ instead.   


%In the right-most diagram of \fig{lattices} the skewed lattice is
%shifted by $(1,1)$. Notice that shifting it by $(2,3)$ instead would
%bring the lattice back onto itself (remember to account for
%wrap-around as demonstrated in \figref{boundary}).  The same is true
%of the rectangular lattice. This is because they are aligned and have
%the same size.  For any lattice, a start position of $\vect{w}$ is
%equivalent to a start position of $\Mod(\vect{w},\vect{h})$ where
%$\vect{h}$ is the size vector of the lattice and $\Mod$ is the
%element-wise modulus function.  The size vector defines the boundary
%of a rectangular unit cell containing one lattice point and coset
%positions.

The STEP operation, \class{Shift}, shifts lattices to an alternate
starting positions.  The operation, \class{Put}, moves them to a new
starting position directly.  \fig{shift} demonstrates positions and
shifts for two different lattices.  Because shifting a lattice by
multiple of one of its generator vectors brings the lattice back to
itself and lattice points in and of themselves are indistinguishable,
lattice starting positions that are greater or less than than one of
a lattice's generating vectors are equivalent to a position in which
the generator has been subtracted out.  In particular, we represent
the position of a lattice as a non-negative coordinate in which all
integer multiples of generator vectors have been subtracted out.
Geometrically, the representative position is the position inside the
parallelepiped unit cell of the lattice as shown in \fig{shift}.


To find the representative position within the parallelepiped unit
cell of a position $~p$, one employs the vector-matrix modulus function
$\Mod(~p,~G)$. It is a direct extension of the scalar modulus
function. For a scalar, the modulus operation can be given by
\[   \mathrm{mod}(a,b) = a + \lfloor a/b \rfloor b  \]
The vector-matrix modulus function, by extension, is
\[   \mathrm{mod}(~a,~B) = a-\lfloor ~a~B^{-1} \rfloor ~B  \]
where the floor and ceiling functions are evaluated element-wise.  If
$~B$ is diagonal, $\mathrm{mod}(~a,~B)$ can be computed element-wise
as $\mathrm{mod}(w_{i},m_{ii})$.


% -------- End subscript underscore
\catcode`\_\active\def_{\hackscore{}}


\Fig{shift}{
  \begin{tabular}{cccc}
        \includegraphics[scale=.8]{xfig/RectLat23Shift00.eps}        &
        \includegraphics[scale=.8]{xfig/RectLat23Shift12.eps}        &
        \includegraphics[scale=.8]{xfig/Skew1Lat23Shift00.eps}       &
        \includegraphics[scale=.8]{xfig/Skew1Lat23Shift13.eps}        \\
       (a) & (b) & (c) & (d) 
  \end{tabular}
%        \includegraphics[scale=.8]{xfig/Skew1Lat23Shift11.eps}        &
%        \includegraphics[scale=.8]{xfig/Skew1Lat23Shift11.eps}        &
%        \includegraphics[scale=.8]{xfig/Skew1Lat23Shift11Boundary.eps}  &
%        \includegraphics[scale=.8]{xfig/Skew1Lat23Shift11Select31.eps}  
%    \begin{tabular}{c}
%      $\left( \begin{array}{cc}
%               2 & 1 \\
%               0 & 3 
%          \end{array} \right) $  \\
%                                 \\
%      (shifted by $(1,1)$)            
%    \end{tabular}
}{ {\bf Shifted lattices} (a) shows a lattice at starting at starting
      at $(0,0)$ and (b) shows it shifted to $(1,2)$.  (c) shows a
      skewed lattice starting at $(0,0)$ and (d) shows it shifted to
      $(1,0)$.  The representative starting positions of the lattices
      are labeled.  
%      Note that the starting position of (d) is
%      equivalent to $(1,0)$, but the representative is actually
%      $(3,1)$.  This is because $(1,0)$ is negative in terms of the
%      $X$ generator---one can see that it is outside the shaded
%      parallelepiped unit cell, while $(3,1)$ is within it.  Also note
%      that, because the grid is a multiple of the lattice sizes, no
%      matter where the lattices start, there are always the same
%      number of sites on the grid (the hollow sites are duplicates).
      }

Because the grid size is a multiple of the lattice size, the same
number of lattice sites remain on the grid, regardless of shifting.
Furthermore, shifting does not affect the number sites inside the
rectangular unit cell or rectangular slices that are multiples of it.

% --------------------------------
% \subsection{Pitch scaled rational coordinates} \label{sec:pitch}
% % --------------------------------
% 
% As a convenience, a scaling---the \var{coord_pitch} vector parameter to
% \function{simp.initialize()}---may be used to set the default scale of
% user-level coordinates.  This allows one to write rational coordinates
% in a natural way using floating-point numbers.  For example, in
% working with a lattice with a pitch of $(2,2)$, 
% a coordinate pitch of $(2,2)$ would allow one to refer to successive lattice points
% using integers and to the coordinates between lattice sites 
% as $(.5,.5)$.  \fig{latticescale} gives some examples of this. 
% 
% \Fig{latticescale}{
%    \begin{tabular}{ccccc}       
%         \includegraphics[scale=.8]{xfig/Rect22Scaled.eps}                &
%         \includegraphics[scale=.8]{xfig/RectLat22Scale.eps}              & &
%         \includegraphics[scale=.8]{xfig/Rect23Scaled.eps}                &
%         \includegraphics[scale=.8]{xfig/Skew1Lat23Scale.eps}             
%     \end{tabular}
% }{{\bf Lattice pitch scaled rational coordinates} The coordinate pitch
%    can be used to scale coordinates to the pitch of a lattice.  In (a) and (b)
%    a coordinate pitch of $(2,2)$ is employed.  (a) shows the rectangular unit
%    cell of the lattice and the pitch scaled rational coordinates 
%    of the sites within it. In (b) and (c) the lattice has a pitch of $(2,3)$ and
%    a coordinate pitch of $(2,3)$ is used. In the lattice diagrams, the darker
%    lines represent integers in the pitch scaled coordinates and the lighter
%    lines represent coordinates with fractional pitch components.}
% 
% % It is also for writing rules and rule
% % libraries where the scale of the lattice on which a signal is
% % allocated may change.
% 
% 
% 
% Pitch scaled coordinates do not break SIMP and STEP's internal requirement
% that coordinates be integers on the grid.  Rational pitch scaled coordinates are
% internally converted to integer grid coordinates by multiplying them by the
% \var{scale} vector.  Because internal coordinates are on an integer
% grid, STEP can use integer arithmetic to compute grid positions
% without resorting to a special rational number class.  It can also
% more easily represent and manipulate\fnmark the  position of a lattice
% than if floating point or rational positions were used.  (Floating
% point coordinates, positions, and shifts are not numerically stable
% and rationals yield more unpredictable positions---especially when
% they are added iteratively as is the case of repeated shifts.)  The
% drawbacks of this scheme are that one must explicitly declare the
% granularity using a combination of grid and lattice sizes and that one
% can not employ arbitrary real shifts.   
% 
% \fntext{When lattices and rules are shifted with the \class{Shift}
%     operation, a STEP may need different scan code for every
%     combination of rule and signal position reached.  When performing
%     a repeating sequence of operations that shift lattices and apply
%     rules, having integer (rather than rational shifts) allows a STEP
%     to compute the unit of repetition of the sequence.  The scans
%     repeat when the positions cycle back to themselves.  When real
%     number shifts are used, this may never happen. }
% 
% of the grid with respect to the
% lattices the `pitch' using the lattice



% Using a scale simplifies writing lattice-gas
% rules where data may be shifted by an amount that is smaller than its
% lattice.  The size of the lattice gives the pitch of coset positions
% where it may be shifted.  Because these coset poitions are finite, a
% STEP can analyize repeated shifts to determine units of space-time
% repetition. [verify correctness of this last wording] And, using a
% proper scaling, one can write coordinates that are scaled to the size
% of the lattice---rather than the pitch.

% \subsection{Snap-to coordinates}
% 
% At the level of STEP primitives, all coordinates are converted to
% integers by applying the appropriate scaling.  When SIMP normalizes
% pitch scaled coordinate vectors (which may be floating point vectors) to
% integers, it first multiplies them by the \var{coord_scale} and then maps to
% the nearest integer within the \var{snapto} range of the result.  The
% nearest-integer mapping suppresses precision errors in representing
% floating point numbers.  
% 
% If a pitch scaled coordinate is not within \var{snapto} of a grid site 
% (an integer after multiplying by the pitch vector), SIMP
% raises an \exception{IndexError}.  In order to avoid snap-to index
% errors one can set the \var{snapto} variable to $.5$.  Eliminating
% these errors may be useful in situations when the scaling does not
% match the lattice size.  One might use such a scaling when the 
% desired geometry does not match the approximate geometry, as in the case
% of approximating a hexagonal lattice. To account for the compression in
% $y$, one might apply a scaling of $(\frac{2}{\sqrt{3}},2)$. 
% [explain this more]
% %lattice where the scaling could be a real number. A scaling of ???
% %would allow the user to approximate the geometry of a hexagonal
% %lattice while using an approximate integer generator.


% --------------------------------
\subsection{Wrap-around compatibility}
% --------------------------------

In order to guarantee that lattices wrap back to themselves and that
the same number of their points remain on the grid when they are
shifted, all lattices must divide the size evenly---\var{size} must be
an integer multiple of the generators of the lattices.  If one
declares a lattice where this does not hold, SIMP raises an exception
that suggesting a suitable \var{size}.  A lattice with a generator
matrix $~G$ is compatible with size vector $~v$ \emph{iff}\  $~v~G^{-1}$ is
an integer.


\Fig{selectrange}{
   \begin{tabular}{cc}       
        \includegraphics[scale=.8]{xfig/Skew1Lat22BadSize.eps}         &
        \includegraphics[scale=.8]{xfig/Skew1Lat22GoodSize.eps}        
    \end{tabular}
}{{\bf Wrap-around compatible lattices and and grid sizes} On the left,
we have a lattice that does not wrap around on a $6 \times 6$ grid.
This is because the size $(6,6)$ is not an integer multiple of the
lattice's generators.
% is an invalid grid size in which the lattice does not wrap around.  
We see that $6\times 4$ is a proper grid size for the lattice. }


% The bounding lattice with orthogonal generators taken from the elements of 
% size must be a sublattice of all lattices declared. 
